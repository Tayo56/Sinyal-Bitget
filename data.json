// Pipedream Node.js code for analyzing top 100 coins on Bitget // Indicators: RSI, MACD, EMA, MA, Volume, Price Action // Timeframes: 5m, 15m, 30m, 1h, 4h, 1d

import axios from "axios";

export default defineComponent({ async run({ steps, $ }) { const symbols = ["BTCUSDT", "ETHUSDT", "DOGEUSDT", "SOLUSDT", "PEPEUSDT", "WIFUSDT", "SHIBUSDT", "BONKUSDT", "FLOKIUSDT", "ORDIUSDT", "NOTUSDT"]; const timeframes = ["5m", "15m", "30m", "1h", "4h", "1d"];

const result = {
  timestamp: new Date().toISOString(),
  timeframes,
  coins: []
};

for (const symbol of symbols) {
  for (const tf of timeframes) {
    try {
      const url = `https://api.bitget.com/api/v2/market/candles?symbol=${symbol}&granularity=${tf}`;
      const res = await axios.get(url);
      const candles = res.data.data;

      if (!candles || candles.length < 26) continue; // Butuh minimal 26 candle

      const closePrices = candles.map(c => parseFloat(c[4])).reverse();
      const volumes = candles.map(c => parseFloat(c[5])).reverse();

      // ==== INDICATOR PERHITUNGAN ====
      const rsi = calcRSI(closePrices);
      const macd = calcMACD(closePrices);
      const ema9 = EMA(closePrices, 9);
      const ema21 = EMA(closePrices, 21);
      const ma20 = SMA(closePrices, 20);
      const ma50 = SMA(closePrices, 50);
      const currentVolume = volumes.at(-1);
      const averageVolume = SMA(volumes, 20).at(-1);
      const pa = detectPriceActionPattern(closePrices);

      // ==== LOGIKA SINYAL ====
      let signal = "WAIT";
      if (rsi > 60 && macd.histogram > 0 && ema9.at(-1) > ema21.at(-1)) signal = "BUY";
      else if (rsi < 40 && macd.histogram < 0 && ema9.at(-1) < ema21.at(-1)) signal = "SELL";

      result.coins.push({
        symbol,
        timeframe: tf,
        rsi,
        macd,
        ema: { ema9: ema9.at(-1), ema21: ema21.at(-1) },
        ma: { ma20: ma20.at(-1), ma50: ma50.at(-1) },
        volume: { current: currentVolume, average: averageVolume },
        price_action: pa,
        signal
      });
    } catch (e) {
      console.log(`Error on ${symbol}-${tf}:`, e.message);
    }
  }
}

// KIRIM KE FRONTEND
await axios.post("https://tayo56.github.io/Sinyal-Bitget/data.json", result, {
  headers: { "Content-Type": "application/json" }
});

return result;

} });

// ===== Fungsi Tambahan ===== function SMA(data, period = 14) { let result = []; for (let i = period - 1; i < data.length; i++) { const slice = data.slice(i - period + 1, i + 1); result.push(slice.reduce((a, b) => a + b) / period); } return result; }

function EMA(data, period = 14) { let k = 2 / (period + 1); let emaArray = []; let ema = SMA(data, period)[0]; for (let i = period; i < data.length; i++) { ema = data[i] * k + ema * (1 - k); emaArray.push(ema); } return emaArray; }

function calcRSI(prices, period = 14) { let gains = 0, losses = 0; for (let i = 1; i <= period; i++) { let diff = prices[i] - prices[i - 1]; if (diff >= 0) gains += diff; else losses -= diff; } let rs = gains / (losses || 1); return parseFloat((100 - 100 / (1 + rs)).toFixed(2)); }

function calcMACD(data) { const ema12 = EMA(data, 12); const ema26 = EMA(data, 26); const macdLine = ema12.slice(-ema26.length).map((v, i) => v - ema26[i]); const signalLine = EMA(macdLine, 9); const histogram = macdLine.slice(-signalLine.length).map((v, i) => v - signalLine[i]); return { value: macdLine.at(-1), signal: signalLine.at(-1), histogram: histogram.at(-1) }; }

function detectPriceActionPattern(data) { const last = data.at(-1); const prev = data.at(-2); if (last > prev) return "Bullish Candle"; if (last < prev) return "Bearish Candle"; return "Doji"; }

